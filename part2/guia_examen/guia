tipus de plugins:
	- Effect plugins: Canvien l'estat abans i/o despres que es pinti. activar shaders, configurar textures...
	- Draw pluginss: recorren els objectes per pintar les primitives. dibuixar amb vertex array
	- Action plugins: executen accions arbitraries en resposta a events (mouse, teclat)
	- Render plugins: dibuixar un frame amb un o mes passos de rendering. shadow mapping

Scene *scene();
Camera *camera();
Plugin *plugin();
GLWidget *glwidget();

al viewer/core/{include, src} tenim totes les classes que s'implementa: [] representar escena, () geometria
- (box), camera, [face], [object], (point), [scene], (vector), [vertex]

/ -------------------------------------------------------------------------------
/ ------------------------- 1. Effect plugins -----------------------------------
/ -------------------------------------------------------------------------------

metodes tipics: preFrame, postFrame, onPluginObject, onObjectAdd
acces dades: glwidget, scene, camera
scene()->objects()->size()
camera()->getObs()
glwidget()->defaultProgram()

-> quan es carrega un plugin es crida a onpluginload 

void ::onPluginLoad()
{
	vs = new QOpenGLShader(QOpenGLShader::Vertex, this);
	vs->compileSourceFile("vertex.vert");
	cout << "VS log:" << vs->log().toStdString() << endl;

	fs = new QOpenGLShader(QOpenGLShader::Fragment, this);
	fs->compileSourceFile("fragment.frag");
	cout << "FS log:" << fs->log().toStdString() << endl;

	program = new QOpenGLShaderProgram(this);
	program->addShader(vs);
	program->addShader(fs);
	program->link();

	et.start();
	/* timers de Qt */
	QTimer *timer = new QTimer(this);
	connect(timer, SIGNAL(timeout()), glwidget(), SLOT(updateGL()));
	timer->start();
}

-> quan s'afegeix un nou model a l'escena 

void ::onObjectAdd()

-> quan s'esborra l'escena

void ::onSceneClear()

->

void ::preFrame()

->

void ::postFrame()
{
	program->bind();

	QMatrix4x4 mvp = camera()->projectionMatrix() * camera()->viewMatrix();
	program->setUniformValue("modelViewProjectionMatrix", mvp);
}

/ --------------------------------------------------------------------------------
/ ----------------------------------- 3. VBA i VBO -------------------------------
/ --------------------------------------------------------------------------------

for (int i=0; i<T; ++i) { 
	glBegin(GL_TRIANLES); glNormal3f(..); glVertex3f(..); ... glEnd();
}

glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, indices)
					(1)		 (2)		(3)			(4)

(1) es la primitiva: gl_triangles, quads...
(2) numero index array (12 triangles -> 12*3 = 36)
(3) tipus index (normalment unsigned_int)
(4) apuntador a l'array previament definit

glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)verts)
					 (1)(2)    (3)       (4)   (5)      (6)

(1) GLuint index 			// vs: layout (location = 0) in vec3 vertex
(2) GLint size				// num coordenades (1,2,3,4)
(3) GLenum type				// tipus de cada coordenada float o double
(4) GLboolean normalized	// convertir valors en [0,1]
(5) GLsizei stride			// normalment un 0
(6) const GLvoid * pointer  // apuntador dades

GLWidget &g = *glwidget();
// pas 1
vector<float> vertices (x,y,z), normals (nx, ny, nz), colors (r,g,b), texCoords (s,t)
vector<unsigned int> indices (i0, i1, i2..)

// pas 2: crear VAO i buffers

GLuint VAO;
g.glGenVertexArray(1, &VAO);

GLuint coordBufferID;
g.glGenBuffers(1, &coordBufferID);

GLuint normalBufferID;
g.glGenBuffers(1, &normalBufferID);
...

// pas 3 defineix VBO

g.glBindVertexArray(VAO);
g.glBindBuffer(GL_ARRAY_BUFFER, coordBufferID);
g.glBufferData(GL_ARRAY_BUFFER, sizeof(float)*vertices.size(), &vertices[0], GL_STATIC_DRAW);
g.glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
g.glEnableVertexAttribArray(0);
g.glBindBuffer(GL_ARRAY_BUFFER, normalBufferID);
g.glBufferData(GL_ARRAY_BUFFER, sizeof(float)*normals.size(), &normals[0], GL_STATIC_DRAW);
g.glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
g.glEnableVertexAttribArray(1);
…
g.glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffersID);
g.glBufferData(GL_ELEMENT_ARRAY_BUFFER,
sizeof(int)*indices.size(),&indices[0], GL_STATIC_DRAW);
g.glBindBuffer(GL_ARRAY_BUFFER,0);
g.glBindVertexArray(0);

// pinta
g.glBindVertexArray(VAO);
g.glDrawArrays(GL_TRIANGLES, 0, numIndices);
g.glBindVertexArray(0);

// pinta amb drawElements
g.glBindVertexArray(VAO);
g.glDrawElements(GL_TRIANGLES, numIndices, GL_UNSIGNED_INT,
(GLvoid*) 0); //numIndices=indices.size()
g.glBindVertexArray(0);

// Draw multiples instances
g.glBindVertexArray(VAO);
g.glDrawElementsInstanced(GL_TRIANGLES, numIndices,
GL_UNSIGNED_INT, (GLvoid*) 0, numInstances);
g.glBindVertexArray(0);

VS: int gl_InstanceID -> instance number (0 … numInstances‐1)

// Clean up
glDeleteBuffers(1, &coordBufferID);
glDeleteBuffers(1, &normalBufferID);
…
glDeleteBuffers(1, &indexBufferID);
glDeleteVertexArrays(1, &VAO);

/ ----------------------
/ ----- FI VAO VBO -----
/ ----------------------